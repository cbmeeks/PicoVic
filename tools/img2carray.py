# img2carray.py
#
# Convert image files into C arrays (16-bit ABGR format)
#
# Copyright (c) 2023 Troy Schrapel
#
# This code is licensed under the MIT license
#
# https://github.com/visrealm/pico-56
#
#

import os
import sys
import glob
import re
import argparse
import datetime
from PIL import Image


def main() -> int:
    """
    main program entry-point
    """
    parser = argparse.ArgumentParser(
        description='Convert images into C-style arrays for use with the PICO-56.',
        epilog="GitHub: https://github.com/visrealm/pico-56")
    parser.add_argument('-v', '--verbose',
                        help='verbose output', action='store_true')
    parser.add_argument(
        '-p', '--prefix', help='array variable prefix', default='')
    parser.add_argument(
        '-o', '--out', help='output file - defaults to base input file name with .c extension')
    parser.add_argument('-r', '--ram', nargs='+', default='',
                        help='input file(s) to store in Pi Pico RAM - can use wildcards')
    parser.add_argument('-i', '--in', nargs='+',
                        help='input file(s) to store in Pi Pico ROM - can use wildcards')
    args = vars(parser.parse_args())

    outSourceFileName = args['out']
    outSourceFile = None
    outHeaderFileName = ''
    outHeaderFile = None

    inRomFileNames = []
    inRamFileNames = []

    for inRomGlob in args['in']:
        for inRomFileName in glob.glob(inRomGlob):
            inRomFileNames.append(inRomFileName)

    for inRamGlob in args['ram']:
        for inRamFileName in glob.glob(inRamGlob):
            inRamFileNames.append(inRamFileName)

    if outSourceFileName:
        outSourceFile = open(outSourceFileName, "w")
        outHeaderFileName = os.path.splitext(outSourceFileName)[0] + ".h"
        outHeaderFile = open(outHeaderFileName, "w")

        outSourceFile.write(getFileHeader(
            outSourceFileName, inRomFileNames, inRamFileNames, args, isHeaderFile=False))
        outHeaderFile.write(getFileHeader(
            outHeaderFileName, inRomFileNames, inRamFileNames, args, isHeaderFile=True))

    for infile in inRamFileNames:
        processImageFile(infile, outSourceFile,
                         outHeaderFile, args, inRam=True)

    for infile in inRomFileNames:
        processImageFile(infile, outSourceFile,
                         outHeaderFile, args, inRam=False)

    outSourceFile.close()
    outHeaderFile.write("\n#endif")
    outHeaderFile.close()

    fileList = ""
    for infile in inRamFileNames:
        fileList += os.path.split(infile)[1] + " (RAM), "
    for infile in inRomFileNames:
        fileList += os.path.split(infile)[1] + ", "

    print(sys.argv[0] + " generated C image arrays in " +
          os.path.join(os.getcwd(), outSourceFile.name) + " from (" + fileList.rstrip(", ") + ")")

    return 0


def getFileHeader(fileName, romFileList, ramFileList, args, isHeaderFile) -> str:
    """
    write the header at the top of the .c/.h file
    """
    timestamp = datetime.datetime.now()
    hdrText = (
        f"/*\n"
        f" * Image file generated by {os.path.split(sys.argv[0])[1]}\n"
        f" * Copyright (c) {timestamp.strftime('%Y')} Troy Schrapel\n"
        f" *\n"
        f" * Generated using the following command:\n"
        f" *   > cd {os.getcwd()}\n"
        f" *   > python3 {' '.join(sys.argv[:])}\n"
        f" *\n"
        f" * Timestamp: {timestamp.strftime('%Y-%m-%d %H:%M:%S')}\n"
        f" *\n"
        f" * Contains the following images:\n"
        f" *\n")

    for infile in ramFileList:
        hdrText += f" * - {os.path.split(infile)[1]} (RAM)\n"

    for infile in romFileList:
        hdrText += f" * - {os.path.split(infile)[1]}\n"

    hdrText += " */\n\n"

    if isHeaderFile:
        baseName = args['prefix'] + "_" + os.path.basename(fileName)
        sanitizedFile = re.sub('[^0-9a-zA-Z]+', '_', baseName.upper())
        hdrText += f"#ifndef _{sanitizedFile}\n"
        hdrText += f"#define _{sanitizedFile}\n\n"
    else:
        hdrText += "#include \"pico/platform.h\"\n"
    hdrText += "#include <inttypes.h>"
    return hdrText


def encodeRGBA32ToABGR16Hex(r, g, b, a=255) -> str:
    """
    encode the 8-bit r, g, b, a values into a single 16-bit 0xabgr hex string
    """
    c = (int(int(a) / 16) & 0xf) << 12
    c |= (int(int(b) / 16) & 0xf) << 8
    c |= (int(int(g) / 16) & 0xf) << 4
    c |= (int(int(r) / 16) & 0xf)
    return "{0:#0{1}x}".format(c, 6)


def encodeRGBA32ToHex(r, g, b, a=255) -> str:
    """
    encode the 8-bit r, g, b, a values into a single 32-bit 0xrgba hex string
    """
    c = (int(r) << 24)
    c |= (int(g) << 16)
    c |= (int(b) << 8)
    c |= int(a)
    return "{0:#0{1}x}".format(c, 10)


def paletteArrayString(pal) -> str:
    """
    convert a palette list into an array string containing 16-bit abgr values
    """
    paletteValues = []
    for i in range(0, len(pal), 3):
        paletteValues.append(encodeRGBA32ToABGR16Hex(
            pal[i], pal[i + 1], pal[i + 2]))
    return "{" + ", ".join(paletteValues) + "}"


def generateArrayComment(infile, src, bpp) -> str:
    """
    generate a comment bloack for an image giving some metadata
    """
    comment = "\n\n/* source: " + infile + "\n"
    comment += " * size  : " + \
               str(src.width) + "px x " + str(src.height) + "px\n"
    comment += " *       : " + \
               str(int(src.width * src.height * bpp / 8)) + " bytes\n"

    if src.palette:
        comment += " * format: 16-bit abgr palette, " + \
                   str(bpp) + "bpp indexed image\n */\n"
    else:
        comment += " * format: 16bpp abgr image\n */\n"
    return comment


def generateProto(varName, src, inRam, isHeader) -> str:
    """
    generate an array prototype (or definition)
    """
    typePrefix = ("extern " if isHeader else " ")
    varNamePrefix = "" if isHeader else (
            "__aligned(4) " + ("" if inRam else "__in_flash() "))
    dataType = "uint8_t " if src.palette else "uint16_t "
    suffix = ";" if isHeader else " = "
    proto = ""

    # if the image has a palette, output that first
    if src.palette:
        proto = typePrefix + "uint16_t " + varNamePrefix + varName + "_pal[]" + suffix
        if not isHeader:
            proto += paletteArrayString(src.palette.tobytes()) + ";"
        proto += "\n"

    # output the image array prototype
    proto += typePrefix + dataType + varNamePrefix + varName + "[]" + suffix
    return proto


def imageToArrayContents(src, pix, bpp) -> str:
    """
    return a string containing a c-style array of the image pixels
    """
    rows = []
    for y in range(src.height):
        row = []
        for x in range(src.width):
            col = pix[x, y]
            if hasattr(col, "__len__"):
                a = 0xff
                if len(col) > 3:
                    a = col[3]
                row.append(encodeRGBA32ToABGR16Hex(col[0], col[1], col[2], a))
            elif bpp == 8:
                row.append("{0:#0{1}x}".format(col, 4))
            else:
                if x & 1:
                    value = value | col
                    row.append("{0:#0{1}x}".format(value, 4))
                else:
                    value = col << 4
        rows.append(", ".join(row))
    return "\n  " + (",\n  ".join(rows))


def processImageFile(infile, srcOutput, hdrOutput, args, inRam) -> None:
    """
    process a single image and output it to the header and source files
    """
    outPathWithoutExt = os.path.splitext(infile)[0]
    closeFile = False
    if srcOutput == None:
        srcOutput = open(outPathWithoutExt + ".c", "w")
        srcOutput.write(getFileHeader(srcOutput.name, [] if inRam else [infile], [
            infile] if inRam else [], args, isHeaderFile=False))
        hdrOutput = open(outPathWithoutExt + ".h", "w")
        hdrOutput.write(getFileHeader(hdrOutput.name, [] if inRam else [infile], [
            infile] if inRam else [], args, isHeaderFile=True))
        closeFile = True

    varName = os.path.split(infile)[1]
    varName = os.path.splitext(varName)[0]
    varName = re.sub('[^0-9a-zA-Z]+', '', args['prefix'] + varName)

    try:
        src = Image.open(infile)
        pix = src.load()

        bpp = 16
        if src.palette:
            bpp = 4 if len(src.palette.tobytes()) <= (16 * 3) else 8

        comment = generateArrayComment(infile, src, bpp)

        hdrOutput.write(comment)
        hdrOutput.write(generateProto(
            varName, src, inRam, isHeader=True) + "\n")

        srcOutput.write(comment)
        srcOutput.write(generateProto(
            varName, src, inRam, isHeader=False) + "{")
        srcOutput.write(imageToArrayContents(src, pix, bpp) + "};")

        src.close()

    except IOError:
        print("cannot convert", infile)

    if closeFile:
        srcOutput.close()
        hdrOutput.write("\n#endif")
        hdrOutput.close()

    return


# program entry
if __name__ == "__main__":
    sys.exit(main())
